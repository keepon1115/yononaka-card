<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多様性を照らすカードゲーム - スタンドアロン版</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* CSSは変更なしのため省略します。元のCSSをそのままお使いください */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background: #f0f4f8;
            color: #333;
            min-height: 100vh;
            display: flex;
        }
        .main-container {
            flex: 1;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        .sidebar {
            width: 300px;
            background: #fff;
            padding: 20px;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
        }
        .game-title {
            text-align: center;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 30px;
        }
        /* プレイヤー登録セクション用のスタイル */
        .player-setup-section {
            background: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .player-input-group {
            margin-bottom: 15px;
        }
        .player-input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        .btn:hover {
            background: #45a049;
        }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .btn-secondary {
            background: #2196F3;
        }
        .btn-secondary:hover {
            background: #1976D2;
        }
        .input-field {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            margin: 10px 0;
        }
        .topic-card {
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .player-area {
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .hand-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #fff;
            padding: 20px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            display: none;
            z-index: 100;
        }
        .reaction-cards {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 10px 0;
        }
        .reaction-card {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid transparent;
            min-width: 120px;
            text-align: center;
            white-space: nowrap;
            transition: all 0.3s;
        }
        .reaction-card:hover {
            border-color: #4CAF50;
            transform: translateY(-2px);
        }
        .reaction-card.used {
            opacity: 0.5;
            cursor: not-allowed;
            background: #e0e0e0;
        }
        .timer-container {
            text-align: center;
            font-size: 48px;
            font-weight: 700;
            margin: 20px 0;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: #fff;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .score-board {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .score-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #ddd;
        }
        .score-item:last-child {
            border-bottom: none;
        }
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: translateY(-20px);
            z-index: 2000;
            max-width: 300px;
        }
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        .toast.reaction-received {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-size: 18px;
            padding: 20px 25px;
        }
        .hidden {
            display: none !important;
        }
        .answer-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 10px 0;
            text-align: center;
        }
        .like-button-container {
            position: fixed;
            bottom: 90px;
            right: 20px;
            z-index: 1050;
        }
        .like-button {
            background: #FF69B4;
            color: white;
            border: none;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 28px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
        }
        .like-button:hover {
            background: #FF1493;
            transform: scale(1.1);
        }
        .like-button:active {
            transform: scale(0.95);
        }
        .heart-animation {
            position: fixed;
            font-size: 30px;
            color: #FF69B4;
            animation: floatUp 1.5s ease-out forwards;
            pointer-events: none;
            z-index: 2001;
        }
        @keyframes floatUp {
            0% { 
                transform: translateY(0) scale(1) rotate(0deg); 
                opacity: 1; 
            }
            100% { 
                transform: translateY(-100px) scale(1.5) rotate(15deg); 
                opacity: 0; 
            }
        }
        .roulette-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }
        .roulette-wheel {
            width: 300px;
            height: 80px;
            border: 3px solid #4CAF50;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            background: #fff;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .roulette-strip {
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            transition: transform 3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        .roulette-item {
            width: 300px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-right: 1px solid #ddd;
        }
        .roulette-pointer {
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 20px solid #4CAF50;
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
        }
        .catch-ball-chat-container {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            background: #f9f9f9;
        }
        .chat-message {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            background: #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .chat-message strong {
            color: #007bff;
        }
        .chat-input-area {
            display: flex;
            margin-top: 10px;
        }
        .chat-input-area input {
            flex-grow: 1;
            margin-right: 10px;
        }
        .round-info {
            background: #007bff;
            color: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
            font-weight: 700;
        }
        .final-results {
            padding: 20px;
        }
        .winner-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .winner-section h3 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        .winner-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        .score-details {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .score-details h4 {
            margin-bottom: 15px;
            color: #333;
        }
        .detail-item {
            padding: 10px;
            margin: 5px 0;
            background: #fff;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
        }
        .reaction-message-highlight {
            color: #ff69b4;
            font-weight: 700;
            font-size: 20px;
        }
        .turn-indicator {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                order: 2;
            }
            .main-container {
                order: 1;
                padding-bottom: 150px;
            }
            .hand-area {
                padding: 10px;
            }
            .reaction-card {
                min-width: 100px;
                font-size: 14px;
            }
            .like-button-container {
                bottom: 120px;
            }
            .roulette-wheel {
                width: 250px;
            }
            .roulette-item {
                width: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1 class="game-title">多様性を照らすカードゲーム</h1>
        
        <div class="player-setup-section" id="playerSetupSection">
            <h2>プレイヤー設定</h2>
            <div class="player-input-group">
                <label for="playerCount">プレイ人数 (2〜4人):</label>
                <input type="number" id="playerCount" class="input-field" min="2" max="4" value="2" onchange="updatePlayerNameInputs()">
            </div>
            <div id="playerNameInputsContainer">
                <!-- プレイヤー名入力欄がここに追加されます -->
            </div>
            <button class="btn" onclick="startGame()">ゲーム開始</button>
        </div>

        <div class="game-area hidden" id="gameArea">
            <div class="round-info" id="roundInfo">ラウンド 1 / 3</div>
            <div class="turn-indicator" id="turnIndicator"></div>
            
            <div class="topic-card" id="topicCard">
                <p id="topicText">お題メーカーがお題を引くのを待っています...</p>
                <button class="btn hidden" id="drawTopicBtn" onclick="drawTopic()">お題を引く</button>
            </div>
            
            <div class="timer-container hidden" id="timerContainer">
                <div id="timerText">0:00</div>
            </div>
            
            <div class="player-area" id="playerArea">
                <h3>回答状況</h3>
                <div id="answerStatus"></div>
            </div>

            <div class="hidden" id="presentationArea">
                <button class="btn hidden" id="startPresentBtn" onclick="startPresentation()">発表スタート！</button>
                <div id="presentationContent"></div>
                
                <div id="catchBallTimeContainer" class="hidden">
                    <h3>キャッチボールタイム</h3>
                    <div id="catchBallTimer" style="font-size:24px; text-align:center; margin:10px 0;">2:00</div>
                    <div class="catch-ball-chat-container" id="chatMessages"></div>
                    <div class="chat-input-area">
                        <input type="text" id="chatInput" class="input-field" placeholder="メモや質問を入力..." onkeypress="handleChatKeyPress(event)">
                        <button class="btn btn-secondary" onclick="sendChatMessage()">メモ送信</button>
                    </div>
                    <button class="btn" id="skipCatchBallBtn" onclick="skipCatchBall()">キャッチボールタイムを終了</button>
                </div>
            </div>
        </div>
    </div>

    <div class="sidebar">
        <h2>ゲーム情報</h2>
        <div id="gameInfo"></div>
        <h2>スコアボード</h2>
        <div class="score-board" id="scoreBoard"></div>
    </div>

    <div class="hand-area" id="handArea">
        <div id="handContent"></div>
    </div>

    <div class="modal" id="modal">
        <div class="modal-content" id="modalContent"></div>
    </div>

    <div class="toast" id="toast"></div>

    <div class="like-button-container hidden" id="likeButtonContainer">
        <button class="like-button" onclick="triggerHeartAnimation(event)">❤️</button>
    </div>

    <script> // type="module" はFirebaseなしでは不要な場合が多いですが、構成によっては残してもOK
        // Firebase関連のimportは削除

        const triggerCards = [
            "この世にまだない〇〇は？", "だらしない〇〇は？", "今社会に必要な〇〇は？", "ありそうでない〇〇は？",
            "明日の〇〇は？", "戦国時代の〇〇は？", "100年後の〇〇は？", "友達になりたくない〇〇は？",
            "思わず〇〇してしまうことは？", "ちょっと怖い〇〇は？", "みんなが気づいていない〇〇は？",
            "夢でも見ない〇〇は？", "今の時代だからこその〇〇は？", "無人島だからこその〇〇は？"
        ];

        const wordCards = [
            "感情","季節","食べ物","乗り物", "服","遊び","場所","人物",
            "色","動物","道具","音楽"
        ];

        const baseReactionCardTexts = [
            "ユニーク！", "実用的！", "びっくり！", "感動的！", "わかりやすいね",
            "おもしろい！", "あたらしい！", "活気があるね", "挑戦的！", "やまとなでしこだね",
            "おしゃれだね", "温故知新だね", "低姿勢だね", "せやね", "しみるね",
            "うまれたね", "なるほど", "それそれ", "やられた！", "うひょー！"
        ];

        let gameState = { // FirebaseのgameStateの代わりにローカルで管理
            phase: 'setup', // 'setup', 'waiting', 'answering', 'presentation', 'catchball', 'reaction', 'roundEnd', 'gameEnd'
            currentRound: 1,
            maxRounds: 3,
            currentTopic: '',
            topicMakerIndex: 0, // お題を決定するプレイヤーのインデックス
            currentPlayerIndex: 0, // 現在操作中のプレイヤーのインデックス（回答、発表など）
            presenterIndex: 0, // 現在発表中のプレイヤーのインデックス
            reactionPlayerIndex: 0, // 現在リアクション中のプレイヤーのインデックス
            timer: 0,
            doublePointPlayerIndex: -1, // -1なら該当者なし
            answers: {}, // { playerIndex: { text: "answer", playerName: "name" } }
            presentationOrder: [], // 発表順 (プレイヤーインデックスの配列)
            currentPresentationOrderIndex: 0, // presentationOrderの現在のインデックス
            catchBallTimer: 0,
            chatLog: [], // { playerName: "name", message: "text" }
            reactionDetails: [], // { fromPlayerIndex, toPlayerIndex, text, points, round }
            usedReactionCardIndexes: {} // { playerIndex: [used_card_indices] }
        };

        let players = []; // [{ name: "Player1", score: 0, reactionsSent: 0, id: 0 }, ...]

        let timerInterval = null;
        let catchBallTimerInterval = null;
        
        // UI要素のキャッシュ (DOMContentLoaded後など)
        let ui = {};

        document.addEventListener('DOMContentLoaded', () => {
            ui = {
                playerSetupSection: document.getElementById('playerSetupSection'),
                gameArea: document.getElementById('gameArea'),
                roundInfo: document.getElementById('roundInfo'),
                turnIndicator: document.getElementById('turnIndicator'),
                topicCard: document.getElementById('topicCard'),
                topicText: document.getElementById('topicText'),
                drawTopicBtn: document.getElementById('drawTopicBtn'),
                timerContainer: document.getElementById('timerContainer'),
                timerText: document.getElementById('timerText'),
                playerArea: document.getElementById('playerArea'),
                answerStatus: document.getElementById('answerStatus'),
                presentationArea: document.getElementById('presentationArea'),
                startPresentBtn: document.getElementById('startPresentBtn'),
                presentationContent: document.getElementById('presentationContent'),
                catchBallTimeContainer: document.getElementById('catchBallTimeContainer'),
                catchBallTimer: document.getElementById('catchBallTimer'),
                chatMessages: document.getElementById('chatMessages'),
                chatInput: document.getElementById('chatInput'),
                skipCatchBallBtn: document.getElementById('skipCatchBallBtn'),
                gameInfo: document.getElementById('gameInfo'),
                scoreBoard: document.getElementById('scoreBoard'),
                handArea: document.getElementById('handArea'),
                handContent: document.getElementById('handContent'),
                modal: document.getElementById('modal'),
                modalContent: document.getElementById('modalContent'),
                toast: document.getElementById('toast'),
                likeButtonContainer: document.getElementById('likeButtonContainer'),
                playerCountInput: document.getElementById('playerCount'),
                playerNameInputsContainer: document.getElementById('playerNameInputsContainer')
            };
            updatePlayerNameInputs(); // 初期表示
            ui.playerCountInput.focus();
        });


        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function showToast(message, isReaction = false) {
            ui.toast.textContent = message;
            ui.toast.classList.add('show');
            if (isReaction) {
                ui.toast.classList.add('reaction-received');
            }
            setTimeout(() => {
                ui.toast.classList.remove('show', 'reaction-received');
            }, isReaction ? 4000 : 3000);
        }

        function updatePlayerNameInputs() {
            const count = parseInt(ui.playerCountInput.value);
            ui.playerNameInputsContainer.innerHTML = '';
            for (let i = 0; i < count; i++) {
                const inputGroup = document.createElement('div');
                inputGroup.className = 'player-input-group';
                inputGroup.innerHTML = `
                    <label for="playerName${i}">プレイヤー ${i + 1} の名前:</label>
                    <input type="text" id="playerName${i}" class="input-field" value="プレイヤー${i + 1}">
                `;
                ui.playerNameInputsContainer.appendChild(inputGroup);
            }
        }

        window.startGame = function() {
            const count = parseInt(ui.playerCountInput.value);
            players = [];
            for (let i = 0; i < count; i++) {
                const nameInput = document.getElementById(`playerName${i}`);
                if (!nameInput || !nameInput.value.trim()) {
                    showToast(`プレイヤー ${i + 1} の名前を入力してください`);
                    return;
                }
                players.push({ 
                    id: i, 
                    name: nameInput.value.trim(), 
                    score: 0, 
                    reactionsSent: 0 
                });
            }

            if (players.length < 2) {
                showToast('最低2人のプレイヤーが必要です');
                return;
            }

            ui.playerSetupSection.classList.add('hidden');
            ui.gameArea.classList.remove('hidden');
            ui.handArea.style.display = 'block';
            ui.likeButtonContainer.classList.remove('hidden');
            
            gameState.phase = 'waiting';
            gameState.topicMakerIndex = 0; //最初のラウンドはプレイヤー0がお題メーカー
            gameState.currentPlayerIndex = gameState.topicMakerIndex; 
            updateGameDisplay();
        }
        
        function updateGameDisplay() {
            // ラウンド情報
            ui.roundInfo.textContent = `ラウンド ${gameState.currentRound} / ${gameState.maxRounds}`;
            
            // ターン表示
            if (players.length > 0 && gameState.currentPlayerIndex < players.length) {
                 let turnText = `${players[gameState.currentPlayerIndex].name}さんのターン`;
                 if (gameState.phase === 'answering' && gameState.topicMakerIndex === gameState.currentPlayerIndex) {
                    turnText += ` (お題メーカー)`;
                 } else if (gameState.phase === 'presentation') {
                    turnText = `${players[gameState.presenterIndex].name}さんの発表`;
                 } else if (gameState.phase === 'catchball') {
                    turnText = `${players[gameState.presenterIndex].name}さんへのキャッチボールタイム`;
                 } else if (gameState.phase === 'reaction') {
                    turnText = `${players[gameState.presenterIndex].name}さんへのリアクション (${players[gameState.reactionPlayerIndex].name}さんが入力中)`;
                 }
                 ui.turnIndicator.textContent = turnText;
            } else {
                ui.turnIndicator.textContent = '';
            }

            // スコアボード
            updateScoreBoard();
            // ゲーム情報 (サイドバー)
            updateGameInfo();


            // お題カードとボタンの表示制御
            ui.drawTopicBtn.classList.add('hidden');
            ui.startPresentBtn.classList.add('hidden'); //発表スタートボタン
            ui.presentationArea.classList.add('hidden');
            ui.catchBallTimeContainer.classList.add('hidden');
            ui.handContent.innerHTML = ''; // 手札エリアクリア

            if (gameState.phase === 'waiting') {
                ui.topicText.textContent = `${players[gameState.topicMakerIndex].name}さんがお題を引くのを待っています...`;
                if (gameState.currentPlayerIndex === gameState.topicMakerIndex) {
                    ui.drawTopicBtn.classList.remove('hidden');
                }
                ui.timerContainer.classList.add('hidden');
                ui.playerArea.classList.add('hidden'); //回答状況はまだ
            } else if (gameState.phase === 'answering') {
                ui.topicText.textContent = gameState.currentTopic;
                ui.timerContainer.classList.remove('hidden');
                updateTimer(gameState.timer);
                ui.playerArea.classList.remove('hidden');
                showAnswerInput(); // 各プレイヤーの入力欄
                updateAnswerStatus();
            } else if (gameState.phase === 'presentation') {
                ui.topicText.textContent = gameState.currentTopic;
                ui.presentationArea.classList.remove('hidden');
                showPresentation();
            } else if (gameState.phase === 'catchball') {
                ui.topicText.textContent = gameState.currentTopic;
                ui.presentationArea.classList.remove('hidden'); //発表内容も表示したまま
                ui.presentationContent.classList.remove('hidden'); 
                ui.catchBallTimeContainer.classList.remove('hidden');
                showCatchBallTime();
            } else if (gameState.phase === 'reaction') {
                ui.topicText.textContent = gameState.currentTopic;
                ui.presentationArea.classList.remove('hidden'); //発表内容も表示したまま
                ui.presentationContent.classList.remove('hidden');
                showReactionSelection();
            } else if (gameState.phase === 'gameEnd') {
                showFinalResults();
            }
        }
        
        function updateGameInfo() {
            ui.gameInfo.innerHTML = `
                <p>現在のラウンド: ${gameState.currentRound} / ${gameState.maxRounds}</p>
                <p>参加者: ${players.length}人</p>
            `;
        }

        function updateScoreBoard() {
            const sortedPlayers = [...players].sort((a, b) => b.score - a.score);
            ui.scoreBoard.innerHTML = sortedPlayers.map(player => `
                <div class="score-item">
                    <span>${player.name}</span>
                    <span>${player.score}点</span>
                </div>
            `).join('');
        }
        
        window.drawTopic = function() {
            // 現在のプレイヤーがお題メーカーか確認
            if (gameState.currentPlayerIndex !== gameState.topicMakerIndex) {
                showToast("あなたはお題メーカーではありません。");
                return;
            }
            const trigger = shuffle(triggerCards)[0];
            const modalContent = `
                <h2>${trigger}</h2>
                <p>〇〇の部分を決めてください</p>
                <button class="btn" onclick="selectWordMethod('self', '${trigger}')">自分で入力（得点2倍）</button>
                <button class="btn btn-secondary" onclick="selectWordMethod('card', '${trigger}')">ワードカードから選ぶ</button>
            `;
            showModal(modalContent);
        };

        window.selectWordMethod = function(method, trigger) {
            if (method === 'self') {
                const modalContent = `
                    <h2>〇〇を入力してください</h2>
                    <input type="text" id="customWord" class="input-field" autofocus>
                    <button class="btn" onclick="setTopic('${trigger}', document.getElementById('customWord').value, true)">決定</button>
                `;
                showModal(modalContent);
                setTimeout(() => document.getElementById('customWord').focus(), 100);
            } else {
                showRouletteModal(trigger);
            }
        };
        
        function showRouletteModal(trigger) {
            const shuffledWords = [];
            for (let i = 0; i < 5; i++) { // ルーレットの見栄えのために複数回シャッフルして連結
                shuffledWords.push(...shuffle(wordCards));
            }
            
            const modalContent = `
                <h2>ワードカードルーレット</h2>
                <div class="roulette-container">
                    <div class="roulette-wheel">
                        <div class="roulette-pointer"></div>
                        <div class="roulette-strip" id="rouletteStrip">
                            ${shuffledWords.map(word => `<div class="roulette-item">${word}</div>`).join('')}
                        </div>
                    </div>
                    <button class="btn" onclick="startRoulette('${trigger}')">スタート！</button>
                </div>
            `;
            showModal(modalContent);
        }

        window.startRoulette = function(trigger) {
            const strip = document.getElementById('rouletteStrip');
            if (!strip) return;
            const totalItemsInVisualStrip = strip.children.length;
            const itemWidth = 300; // .roulette-item の幅と合わせる
            
            // wordCards からランダムに1つ選び、そのインデックスを元にルーレットの停止位置を決める
            const actualWordIndex = Math.floor(Math.random() * wordCards.length);
            // ルーレットストリップ内で、選ばれたワードが複数回現れるうちの、ある程度の回転を見せるための位置
            // 例えば、wordCards.length の2倍以降の位置で停止させる
            const targetStopIndexInStrip = actualWordIndex + (wordCards.length * (Math.floor(Math.random() * 2) + 2));
            
            const finalPosition = -(targetStopIndexInStrip * itemWidth) + (itemWidth / 2); // 中央に止まるように調整（roulette-wheelの幅とitemの幅が同じ場合）
                                                                                       // ポインタがある場合はポインタ位置に合わせる
            
            strip.style.transform = `translateX(${finalPosition}px)`;
            
            setTimeout(() => {
                const selectedWord = wordCards[actualWordIndex];
                setTopic(trigger, selectedWord, false);
            }, 3000); // アニメーション時間
        };


        window.setTopic = function(trigger, word, isDouble) {
            if (!word || !word.trim()) {
                showToast("有効なワードを入力してください。");
                return;
            }
            gameState.currentTopic = trigger.replace('〇〇', word.trim());
            gameState.doublePointPlayerIndex = isDouble ? gameState.topicMakerIndex : -1;
            gameState.phase = 'answering';
            gameState.timer = 120; // 2分
            gameState.answers = {}; // 回答リセット
            gameState.currentPlayerIndex = 0; // 回答はプレイヤー0から順番に
            
            hideModal();
            updateGameDisplay();
            startLocalTimer();
        };

        function startLocalTimer() {
            if (timerInterval) clearInterval(timerInterval);
            updateTimer(gameState.timer); // 初期表示
            timerInterval = setInterval(() => {
                gameState.timer--;
                updateTimer(gameState.timer);
                if (gameState.timer <= 0) {
                    clearInterval(timerInterval);
                    handleAnsweringTimeUp();
                }
            }, 1000);
        }
        
        function updateTimer(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            ui.timerText.textContent = `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        function handleAnsweringTimeUp() {
            showToast("回答時間終了！");
            // まだ回答していないプレイヤーがいれば、その人のターンは終了
            // 全員の回答が揃っていなくても発表フェーズへ
            if (Object.keys(gameState.answers).length < players.length) {
                showToast("未回答のプレイヤーがいます。発表は回答者のみで行います。");
            }
            preparePresentation();
        }

        function showAnswerInput() {
            // 現在のプレイヤーがまだ回答していなければ入力欄を表示
            if (!gameState.answers[gameState.currentPlayerIndex]) {
                ui.handContent.innerHTML = `
                    <h3>${players[gameState.currentPlayerIndex].name}さんの回答</h3>
                    <input type="text" id="myAnswer" class="input-field" placeholder="回答を入力">
                    <button class="btn" onclick="submitAnswer()">送信して次の人へ</button>
                `;
                setTimeout(()=> document.getElementById('myAnswer')?.focus(), 0);
            } else {
                // 既に回答済みなら、次のプレイヤーへ促すか、全員回答済みなら発表準備へ
                ui.handContent.innerHTML = `<p>${players[gameState.currentPlayerIndex].name}さんは回答済みです。次のプレイヤーへどうぞ。</p>`;
                // ここで自動で次に進めるか、ボタンを出すかなど検討
            }
        }

        window.submitAnswer = function() {
            const answerInput = document.getElementById('myAnswer');
            if (!answerInput) return;
            const answerText = answerInput.value.trim();
            if (!answerText) {
                showToast("回答を入力してください。");
                return;
            }

            gameState.answers[gameState.currentPlayerIndex] = {
                text: answerText,
                playerName: players[gameState.currentPlayerIndex].name
            };
            
            showToast(`${players[gameState.currentPlayerIndex].name}さんの回答を送信しました`);
            updateAnswerStatus();

            // 次のプレイヤーへ
            gameState.currentPlayerIndex++;
            if (gameState.currentPlayerIndex >= players.length) {
                // 全員のターンが一巡
                clearInterval(timerInterval); // 全員回答したらタイマー停止
                preparePresentation();
            } else {
                // 次のプレイヤーの入力へ
                updateGameDisplay();
                 // 次のプレイヤーに入力を促すメッセージ
                showToast(`${players[gameState.currentPlayerIndex].name}さんの番です。デバイスを渡してください。`, true);
            }
        };
        
        function updateAnswerStatus() {
            const answeredCount = Object.keys(gameState.answers).length;
            ui.answerStatus.innerHTML = `<p>回答済み: ${answeredCount} / ${players.length} 人</p>`;
        }

        function preparePresentation() {
            const answeredPlayerIndices = Object.keys(gameState.answers).map(idx => parseInt(idx));
            if (answeredPlayerIndices.length === 0) {
                showToast("回答者が誰もいません。このラウンドは終了します。");
                handleRoundEnd();
                return;
            }
            gameState.presentationOrder = shuffle(answeredPlayerIndices);
            gameState.currentPresentationOrderIndex = 0;
            gameState.phase = 'presentation';
            if (gameState.presentationOrder.length > 0) {
                gameState.presenterIndex = gameState.presentationOrder[gameState.currentPresentationOrderIndex];
                gameState.currentPlayerIndex = gameState.presenterIndex; //発表者が操作
            }
            updateGameDisplay();
        }
        
        // startPresentationはHTMLからは呼ばれず、preparePresentationから直接showPresentationが呼ばれる想定
        // もし発表開始ボタンが必要なら、preparePresentationの最後にボタン表示処理を追加
        
        function showPresentation() {
            if (gameState.currentPresentationOrderIndex >= gameState.presentationOrder.length) {
                // 全員の発表が終了
                handleRoundEnd(); // 全員の発表が終わったらラウンド終了処理
                return;
            }
            
            gameState.presenterIndex = gameState.presentationOrder[gameState.currentPresentationOrderIndex];
            const presenterData = gameState.answers[gameState.presenterIndex];

            ui.presentationContent.innerHTML = `
                <div class="answer-display">
                    <h3>${presenterData.playerName}の発表</h3>
                    <p style="font-size: 28px; margin: 20px 0; font-weight: 700;">${presenterData.text}</p>
                    <p>30秒で説明してください（口頭でお願いします）</p>
                </div>
            `;
            ui.presentationContent.classList.remove('hidden');


            // 発表者の操作でキャッチボールタイムへ進むボタン
            ui.startPresentBtn.textContent = 'キャッチボールタイムへ進む'; // ボタン文言変更
            ui.startPresentBtn.classList.remove('hidden');
            ui.startPresentBtn.onclick = () => {
                 gameState.phase = 'catchball';
                 gameState.catchBallTimer = 120; // 2分
                 gameState.chatLog = []; // チャットログリセット
                 updateGameDisplay();
                 startCatchBallLocalTimer();
            };
        }

        function startCatchBallLocalTimer() {
            if (catchBallTimerInterval) clearInterval(catchBallTimerInterval);
            updateCatchBallTimerDisplay(gameState.catchBallTimer);
            catchBallTimerInterval = setInterval(() => {
                gameState.catchBallTimer--;
                updateCatchBallTimerDisplay(gameState.catchBallTimer);
                if (gameState.catchBallTimer <= 0) {
                    clearInterval(catchBallTimerInterval);
                    skipCatchBall(); // 時間切れで自動スキップ
                }
            }, 1000);
        }
        
        function updateCatchBallTimerDisplay(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            ui.catchBallTimer.textContent = `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        function showCatchBallTime() {
            updateCatchBallTimerDisplay(gameState.catchBallTimer);
            updateChatMessages(); //チャット表示更新
            // スキップボタンは常に表示 (発表者か誰でもスキップできる想定)
            ui.skipCatchBallBtn.style.display = 'block';
        }

        window.skipCatchBall = function() {
            if (catchBallTimerInterval) clearInterval(catchBallTimerInterval);
            gameState.phase = 'reaction';
            // リアクションは発表者以外のプレイヤーが順番に行う
            gameState.reactionPlayerIndex = 0; // 最初のリアクションプレイヤー
            // gameState.currentPlayerIndex は reactionPlayerIndex に合わせる
            // ただし、reactionPlayerIndex が発表者自身ならスキップ
            advanceToNextReactionPlayer(); 
            updateGameDisplay();
        };
        
        function advanceToNextReactionPlayer() {
            // 発表者自身はリアクションしないのでスキップ
            while (gameState.reactionPlayerIndex < players.length && 
                   gameState.reactionPlayerIndex === gameState.presenterIndex) {
                gameState.reactionPlayerIndex++;
            }
            if (gameState.reactionPlayerIndex >= players.length) {
                // 全員のリアクションが終了
                moveToNextPresentationOrEnd();
            } else {
                gameState.currentPlayerIndex = gameState.reactionPlayerIndex; //操作者を更新
            }
        }

        window.sendChatMessage = function() {
            const messageText = ui.chatInput.value.trim();
            if (!messageText) return;

            // キャッチボールタイムでは、現在の操作プレイヤー（発表者または他の人）がメモを残せる
            const chatterName = players[gameState.currentPlayerIndex]?.name || "ゲスト";
            gameState.chatLog.push({ playerName: chatterName, message: messageText });
            
            updateChatMessages();
            ui.chatInput.value = '';
            ui.chatInput.focus();
        };
        
        window.handleChatKeyPress = function(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        };

        function updateChatMessages() {
            ui.chatMessages.innerHTML = gameState.chatLog.map(msg => `
                <div class="chat-message">
                    <strong>${msg.playerName}:</strong> ${msg.message}
                </div>
            `).join('');
            ui.chatMessages.scrollTop = ui.chatMessages.scrollHeight;
        }
        
        function showReactionSelection() {
             // gameState.reactionPlayerIndex が現在のリアクションを行うプレイヤー
            const reactor = players[gameState.reactionPlayerIndex];
            
            // 使用済みカードの管理を初期化 (ラウンドごと、プレイヤーごと)
            if (!gameState.usedReactionCardIndexes[reactor.id]) {
                gameState.usedReactionCardIndexes[reactor.id] = [];
            }
            const usedIndexes = gameState.usedReactionCardIndexes[reactor.id];

            const availableCards = baseReactionCardTexts.map((text, index) => ({
                text,
                index,
                used: usedIndexes.includes(index)
            }));

            ui.handContent.innerHTML = `
                <div style="text-align: center; margin-bottom: 10px;">
                    <h3 class="reaction-message-highlight">
                        ${reactor.name}さん、発表者（${players[gameState.presenterIndex].name}さん）へ<br>
                        カードに書かれている言葉を読み上げて、<br>
                        気持ちを込めて渡してくださいね。
                    </h3>
                </div>
                <div class="reaction-cards">
                    ${availableCards.map(card => `
                        <div class="reaction-card ${card.used ? 'used' : ''}" 
                             onclick="${card.used ? '' : `sendReaction(${card.index})`}">
                            <div>${card.text}</div>
                        </div>
                    `).join('')}
                </div>
                <div style="text-align: center; margin-top: 10px;">
                     <button class="btn btn-secondary" onclick="skipReaction()">リアクションをスキップ</button>
                </div>
            `;
             // 30秒タイマー (オプション、スタンドアロンではプレイヤー判断でも良い)
             // このフェーズのタイマーは一旦省略
        }
        
        window.skipReaction = function() {
            showToast(`${players[gameState.reactionPlayerIndex].name}さんはリアクションをスキップしました。`);
            gameState.reactionPlayerIndex++;
            advanceToNextReactionPlayer();
            updateGameDisplay();
        }

        window.sendReaction = function(cardIndex) {
            const reactorIndex = gameState.reactionPlayerIndex;
            const presenter = players[gameState.presenterIndex];
            const reactor = players[reactorIndex];

            const reactionText = baseReactionCardTexts[cardIndex];
            const points = Math.floor(Math.random() * 5) + 1; // 1〜5点
            
            const isDouble = gameState.doublePointPlayerIndex === gameState.presenterIndex;
            const finalPoints = points * (isDouble ? 2 : 1);
            
            presenter.score += finalPoints;
            reactor.reactionsSent += 1;
            
            gameState.usedReactionCardIndexes[reactor.id].push(cardIndex);
            
            gameState.reactionDetails.push({
                fromPlayerIndex: reactorIndex,
                toPlayerIndex: gameState.presenterIndex,
                text: reactionText,
                points: finalPoints,
                round: gameState.currentRound
            });

            showToast(`${reactor.name}さんが${presenter.name}さんに「${reactionText}」(${finalPoints}点) を送りました！`, true);
            
            // 次のリアクションプレイヤーへ
            gameState.reactionPlayerIndex++;
            advanceToNextReactionPlayer();
            updateGameDisplay();
        };

        function moveToNextPresentationOrEnd() {
            gameState.currentPresentationOrderIndex++;
            if (gameState.currentPresentationOrderIndex >= gameState.presentationOrder.length) {
                // 全員の発表とリアクションが終了
                handleRoundEnd();
            } else {
                // 次の発表者へ
                gameState.presenterIndex = gameState.presentationOrder[gameState.currentPresentationOrderIndex];
                gameState.currentPlayerIndex = gameState.presenterIndex;
                gameState.phase = 'presentation';
                 // リアクションプレイヤーインデックスもリセット
                gameState.reactionPlayerIndex = 0;
                advanceToNextReactionPlayer(); // reactionPlayerIndexを適切に設定
            }
            updateGameDisplay();
        }

        function handleRoundEnd() {
            showToast(`ラウンド ${gameState.currentRound} 終了！`);
            // プレイヤーごとの使用済みリアクションカードをリセット
            gameState.usedReactionCardIndexes = {};

            if (gameState.currentRound >= gameState.maxRounds) {
                gameState.phase = 'gameEnd';
            } else {
                gameState.currentRound++;
                gameState.phase = 'waiting';
                // 次のお題メーカー (前のラウンドのお題メーカーの次の人)
                gameState.topicMakerIndex = (gameState.topicMakerIndex + 1) % players.length;
                gameState.currentPlayerIndex = gameState.topicMakerIndex;
                gameState.answers = {};
                gameState.presentationOrder = [];
                gameState.currentPresentationOrderIndex = 0;
                gameState.doublePointPlayerIndex = -1;
                gameState.chatLog = [];
            }
            updateGameDisplay();
        }

        function showFinalResults() {
            let waiwaiKing = { name: '', score: -1 };
            let emotionalDoctor = { name: '', count: -1 };
            
            players.forEach(player => {
                if (player.score > waiwaiKing.score) {
                    waiwaiKing = { name: player.name, score: player.score };
                }
                if (player.reactionsSent > emotionalDoctor.count) {
                    emotionalDoctor = { name: player.name, count: player.reactionsSent };
                }
            });
            
            const playerDetailMap = {};
            players.forEach(p => {
                playerDetailMap[p.id] = { name: p.name, reactionsReceived: [] };
            });

            gameState.reactionDetails.forEach(detail => {
                if (playerDetailMap[detail.toPlayerIndex]) {
                     playerDetailMap[detail.toPlayerIndex].reactionsReceived.push({
                        fromName: players[detail.fromPlayerIndex].name,
                        text: detail.text,
                        points: detail.points,
                        round: detail.round
                    });
                }
            });
            
            const modalContent = `
                <div class="final-results">
                    <h2 style="text-align: center; margin-bottom: 30px;">🎉 最終結果発表 🎉</h2>
                    
                    <div class="winner-section">
                        <div class="winner-icon">👑</div>
                        <h3>わいわいキング</h3>
                        <p style="font-size: 24px;">${waiwaiKing.name || '該当者なし'}</p>
                        <p style="font-size: 20px;">${waiwaiKing.score > -1 ? waiwaiKing.score + '点' : '-'}</p>
                    </div>
                    
                    <div class="winner-section" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                        <div class="winner-icon">🎓</div>
                        <h3>エモーショナル博士</h3>
                        <p style="font-size: 24px;">${emotionalDoctor.name || '該当者なし'}</p>
                        <p style="font-size: 20px;">${emotionalDoctor.count > -1 ? emotionalDoctor.count + '枚のリアクションカードを贈りました' : '-'}</p>
                    </div>
                    
                    <div class="score-details">
                        <h4>各プレイヤーが受け取ったリアクション内訳</h4>
                        ${Object.values(playerDetailMap).map(data => `
                            <div style="margin-bottom: 20px;">
                                <h5 style="color: #333; margin-bottom: 10px;">${data.name}さん</h5>
                                ${data.reactionsReceived.length > 0 ? data.reactionsReceived.map(r => `
                                    <div class="detail-item">
                                        ラウンド${r.round}: ${r.fromName}さんから「${r.text}」(${r.points}点)
                                    </div>
                                `).join('') : '<p>リアクションはありませんでした</p>'}
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="text-align: center; margin-top: 30px;">
                        <button class="btn" onclick="location.reload()">新しいゲームを始める</button>
                    </div>
                </div>
            `;
            showModal(modalContent, false); // 閉じられないモーダル
        }

        window.triggerHeartAnimation = function(event) {
            const heart = document.createElement('div');
            heart.className = 'heart-animation';
            heart.innerHTML = '❤️';
            // クリック位置にハートを表示
            heart.style.left = event.clientX - 15 + 'px'; 
            heart.style.top = event.clientY - 15 + 'px';
            document.body.appendChild(heart);
            setTimeout(() => heart.remove(), 1500);
        };

        function showModal(content, closable = true) {
            ui.modalContent.innerHTML = content;
            ui.modal.style.display = 'flex';
            if (closable) {
                ui.modal.onclick = function(event) {
                    if (event.target === ui.modal) {
                        hideModal();
                    }
                };
            } else {
                ui.modal.onclick = null; // 閉じられないように
            }
        }

        function hideModal() {
            ui.modal.style.display = 'none';
        }

    </script>
</body>
</html>